# üß™ Scientific ML: Reaction-Diffusion Generative Surrogate

> **"From Math to Magic: Simulating Nature's Patterns in Milliseconds"**

![Python](https://img.shields.io/badge/Python-3.10%2B-blue?style=for-the-badge&logo=python)
![JAX](https://img.shields.io/badge/JAX-Accelerated-red?style=for-the-badge&logo=google)
![Equinox](https://img.shields.io/badge/Equinox-Neural%20Networks-green?style=for-the-badge)
![Diffrax](https://img.shields.io/badge/Diffrax-Solvers-orange?style=for-the-badge)

---

## üåå The Problem: Simulating Complexity is Slow
Nature is full of beautiful, complex patterns‚Äîfrom the stripes on a zebra to the spots on a leopard. These are often modeled by **Reaction-Diffusion systems** (like the famous Gray-Scott model). 

To simulate these, scientists traditionally solve **Partial Differential Equations (PDEs)** step-by-step. 
*   **The downside?** It's computationally expensive. 
*   **The bottleneck?** Exploring millions of parameter combinations ($F$, $k$) to find stable patterns takes forever.

## üöÄ The Solution: AI as a Digital Twin
We built a **Physics-Informed Generative Surrogate** using **JAX and Diffusion Models**. 
Instead of solving the math step-by-step, our AI learns the *rules* of the universe.

*   **Input**: Physical Parameters (Feed Rate $F$, Kill Rate $k$)
*   **Output**: The fully evolved pattern (in one shot!)
*   **Speed**: **100x - 1000x faster** than traditional solvers.

---

## ‚ú® Visuals
*Below is a glimpse of the training data generated by our High-Fidelity Solver:*

![Simulation Preview](data_preview.gif)

*(The model learns to generate these exact dynamics!)*

---

## üõ†Ô∏è The Tech Stack
We use the bleeding-edge **JAX Ecosystem** for maximum performance:

| Component | Technology | Why? |
| :--- | :--- | :--- |
| **Backend** | `JAX` | Autograd + XLA compilation (Lightning fast on GPU/TPU) |
| **Model** | `Equinox` | Elegant, PyTorch-like syntax for JAX |
| **Solver** | `Finite Difference` | Ground-truth physics generation |
| **Architecture** | `Conditional U-Net` | Conditioned on physics parameters ($F$, $k$) & Time ($t$) |

---

## ‚ö° Quick Start

### 1. Installation
Clone the repo and install dependencies (we recommend a virtual env):
```bash
python -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
```

### 2. Generate Data üß¨
Create your own physics-grounded dataset:
```bash
python generate_data.py --samples 100 --steps 1000
```

### 3. Visual Verification üëÅÔ∏è
Check what you generated:
```bash
python visualize_data.py
```
*(This generates `data_preview.gif`)*

### 4. Train the Surrogate üß†
Teach the AI the laws of physics:
```bash
python train.py --epochs 50 --batch_size 64
```

### 5. Evaluate & Generate üé®
Ask the AI to dream up new patterns:
```bash
python evaluate.py
```

---

## üî¨ Scientific Methodology
1.  **Physics Enforcement**: We don't just use random images. We use real numerical solutions of the **Gray-Scott Equations**.
    $$ \frac{\partial U}{\partial t} = D_u \nabla^2 U - UV^2 + F(1-U) $$
2.  **Conditioning**: The Neural Network is **conditioned** on the scalar parameters $F$ and $k$, meaning it serves as a controllable function approximator for the PDE operator.

---

## üë• Team
*   **[Your Name / Team Name]** - *Lead Engineer & Researcher*
*   *Scientific ML Challenge - Track 1 Submission*

---
> *Built with ‚ù§Ô∏è and JAX.*
